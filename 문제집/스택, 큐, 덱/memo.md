data를 다루는 구조 중 하나인 스택 큐 덱이다. 이들은 입력과 출력 순서에 특징을 가지고있는데, 후입선출 선입선출 양방향 으로 나뉜다. 일단 드는 생각은 문제를 읽고 그때그때 필요한 애들이 떠오르지 않을까?? 중요해보이는건 빠르고 간단하게 스택, 큐, 덱을 구현하고 활용할 생각을 하자. 그리고 필요하다면 원형큐까지?? 어떤걸 쓸지 알려면 나중에 장단점을 잘 정리해보자.

## 스택
우선 파이썬에서 스택은 따로 제공하지 않고 리스트를 활용하면 된다. a.pop()은 스택을 위한 함수로 마지막 요소를 추출한다. 요긴하게 활용하자. a.pop()과 a.append()는 스택에서 활용할 수 있는 함수이고 모두 시간복잡도가 O(1)이므로 부담없이 사용해도 된다.  a.pop(0)의 시간복잡도가 O(n)인것과 비교하면 매우 안정적이라고 볼 수 있다. top에 위치한 데이터를 접근할때는 유리하지만 외의 데이터는 접근이 불가하다는 치명적인 단점이 있다. 모두 탐색하려면 모두 제거하면서 상자를 들어내야한다 허허허...

## 큐
선입선출 들어온대로 나간다. 그냥 길 걸어가는 사람이라고 생각하면 된다. 이게 그림으로 생각하면 너무 쉬운데 좀 구현할때 성가신 부분은 앞부분이 날라가면 리스트를 다 당겨줘야하는지... 아니면 그대로 둘지 시간복잡도 생각하면 으으 머리가 아픈데 사실 웬만하면 리스트를 옮겨주는 경우는 거의 없고 front rear를 index 지정해서 옮겨다니는 식으로 하자. 음 이거 앞부분을 실제 list에서 pop하게 되면 시간 복잡도가 O(n)이 나오게 되어 너무 무겁다. 선형큐의 단점은 지정된 크기를 넘어가게 되면 삽입이 불가능해지는 경우가 생기기도 한다. 그래서 이를 보완한 원형큐가 있다.
### 원형큐
선형큐의 단점을 순환식으로 돌려 보완했다. 처음에 문제를 잘 읽고 크기만 잘 지정해주면 계속 돌려도 계속 사용가능이다. 8칸이면 7개 들어가면full이다. 8개 다 넣으면 죽는다 보면 된다. front = rear는 clear로 보는데 8개를 채우면 front = rear가 되어버린다. 그냥 @_@어지럽다. front, rear의 위치로 데이터의 삭제가 이루어지고 (front가 존재하는 곳은 비어있는 판정) 삽입은 뭐 당연히 쉬우니 시간복잡도가 O(1)된다. 큐도 좋다. 단점은 사이의 데이터 활용이 힘들다는 점으로 스택과 비슷하다.

## 덱
덱은 양방향 큐이다. 뭐 그냥 말이 어려운거지 음.. 화장실 물 나오는 호스랑 다른게 없다. 양쪽 구멍으로 들어오고 나오고가 가능한거 아닌가. 덱은 단점으로는 가운데 값들이 삭제 삽입이 어렵다 정도가 있고 사실 원하는거 다 때려박은거라 장점이 훨씬 많을 수 밖에없다. 시작점이나 끝점의 값을 넣고 빼는걸 많이 수행해야 하는 경우 압도적으로 유리하고 python의 경우에는 deque() 함수를 제공하니 그냥 가져다가 마구마구 사용하자 ㅋ_ㅋ

문제를 풀어보면서 느끼는 점은 문제를 흐름 따라가면서 그대로 풀면 뭐 당연히 풀린다. 하지만 역시 관건은 시간이다. 리스트에서 원소를 날리는 del 함수는 최악의 경우 n의 시간복잡도를 가진다. 하지만 이를 그냥 0 등의 숫자로 바꾸고 풀어버리면 1의 시작복잡도를 가진다. 어떤걸 선택할건가? 와 같은 선택을 해야한다. 과정들을 세분화해서 각각 시간복잡도를 따져보고 간소화 할 수 있는 부분들,혹은 해야하는 부분을 찾아보고 이래도 안된다면 방법 혹은 순서가 잘못된거다. 방법 잘못된거면 어캐 푸냐고? 나도 모르지.. 근데 문제만 따라가기보다는 여러가지 생각을 해보자. 리스트가 아니라 포인터를 움직이거나, 바구니에 담으면서 움직이고 또 담고 빼고 하기보다는 다 담아놓고 한번에 짤라버리는등 반복되는 행동을 줄이자. 행동을 하나씩 하면서 핵심을 봐보는 버릇을 해보자.
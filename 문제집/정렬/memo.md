# 정렬 알고리즘
우리가 보는 숫자, 혹은 문제에서는 정렬이 필요없는 경우가 많다. 숫자가 많아야 10개, 100개 정도이기 때문이다. 하지만 수십만 혹은 수억이 넘어가는 데이터를 활용할때는 당연하게도 압도적으로 정렬이 되어있는게 활용가치가 높다고 볼 수 있다. 정렬이 되어있으면 **이진탐색**이라는 강력한 알고리즘이 사용 가능하다.
정렬에는 크게 두가지의 방법이 있는데 하나는 $$O(n^2)$$의 시간 복잡도를 가지는 정렬과 $$O(n * log n)$$의 시간 복잡도를 가지는 정렬이 있다. 당연히 다 알아야겠지만 테스트를 보다보면 시간 오류가 나는 경우는 대부분 n^2 짜리가 아닌 n log n 짜리로 풀게 되어있기 때문인 경우가 많다. 이를 주의하면서 공부해보자. **어느 상황에서 사용하는지... 필요충분 조건에 주목하고 기억해보자....**

## O(n^2) 정렬 알고리즘
1. 버블정렬
    정렬의 기본형(아마도?) 방향을 정한 후, 위로 가는 방향이라면 왼쪽과 오른쪽을 비교해 항상 왼쪽이 더 작게 밑에서 부터 위로 비교를 시작하는 것이다. 그러면 한번 쭉 훑었을때는 가장 오른쪽에 가장 큰 숫자가 있을 것이고 다음에는 가장 작은숫자부터 가장 오른쪽의 바로 옆칸까지만 진행하면 된다. 이렇게 한 칸씩 오른쪽에 있는 칸을 제외하면서 정렬을 해주면 된다. 계산 크기는 버블과 똑같이 n(n-1)/2 번 비교해야한다.
2. 선택정렬
    교실을 예로 들면 키순서를 1번부터 2번 3번 찾으면서 제일 큰 친구까지 세우는 것이다. 계산 크기는 버블과 똑같이 n(n-1)/2 번 비교해야한다.
3. 삽입정렬
    정렬이 사용되는 상황마다 편차가 심하다. 그래도 o(N^2) 알고리즘 중에는 속도가 빠른편이라고 볼 수 있다. 특히 배열이 작을 때 매우 효과적인데, 일부 알고리즘에서는 사이즈가 클때는 n log n 알고리즘을 사용하다가 배열의 크기가 작을때는 삽입정렬을 사용하기도 한다고 한다.

## O(n log n) 정렬 알고리즘
밑의 세 알고리즘은 평균적으로 O(n log n)의 성능을 보이나 퀵 정렬은 최악의 경우에는 n^2 으로 뒤지기도 한다. 실제로는 퀵 정렬이 가장 빨라 이를 활용하고 조금 개량해서 최악의 경우가 발생하지 않도록 코드를 짜고, 나쁜 경우에는 힙 정렬로 전환한다고 한다. 
1. 병합 정렬
    성능은 퀵정렬보다 떨어지지만 장점은 데이터의 상태에 별 영향을 받지 않는다는 점이다.
    방법은 일단 배열을 쪼갠다.쪼갠 후 다시 하나씩 병합을 해준다. 병합을 해준 배열은 정렬이 되어있으므로 이제 또 병합을 실시할때는 가장 왼쪽의 원소는 가장 원소임을 확신할 수 있다. 그래서 가장 왼쪽의 원소끼리 비교하면서 더 작은 원소를 새로운 배열에 넣는 식으로 정렬을 진행해주면 된다.
2. 힙 정렬
    선택정렬과 거의 같은 알고리즘이다. 허나 선택정렬은 그냥 일렬로 세우는 것이고 힙정렬은 힙을 사용하는 것이 유일한 차이이다. 힙 트리를 이용하는데, 힙 트리를 모르겠다면 따로 공부하자..!
3. 퀵 정렬
    이름에서 알 수 있듯이 평균적인 상황에서 최고의 성능을 자랑한다. 원소 하나를 기준으로 더 큰걸 찾아 오른쪽으로 다 던지고 작은걸 왼쪽으로 던지는 식으로 다 정렬해준다.
    허나 이 알고리즘의 단점은 운에 기반한다. 상황에따라 $$O(n^2)$$ 의 시간복잡도를 보일 수 있다.
    ### 구현
    1. 피봇 (아무거나 정해도 된다. 하지만 효율을 위해서는 중간값이 최고)을 정한뒤 리스트를 한 바퀴 돌며 비교하여 큰값, 작은값, 같은 값을 새로운 리스트에 담는다.
    2. 작은 값, 큰 값이 담긴 리스트에는 재귀함수를 이용하여 다시 퀵 정렬을 돌려준다. 그러면 알아서 다 쪼개지면서 정렬이 될것이다.
    3. 피봇을 잡을때 그냥 가장 앞 값을 잡아도 되고, 아니면 그냥 제일 가운데 값을 잡아도 된다.
    4. 재귀함수이므로 끝나는 조건 (길이가 1일때)을 명시해줘야 함수가 성공적으로 종료될 것이다.
4. 트리 정렬

정렬을 정리하면서 드는 생각은 내가 사용할 수 있는 python의 sort함수는 과연 어떤 방식을 차용할까였다. python의 sort()함수는 하이브리드 정렬을 이용한다. 병합정렬과 삽입정렬을 결합한 하이브리드 정렬인 Timsort를 활용한다. 최선의 경우에는 n의 시간복잡도를. 최악의 경우에도 n log n 의 시간 복잡도를 자랑하니 그냥 믿고 써도 되는거 아닐까..? 그냥 sort()로 해결된다면 믿고 쓰자!
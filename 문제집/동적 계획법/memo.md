# 동적계획법
dynamic programing 음 이름만 들으면 뭔가 재밌어 보인다. 최적화 이론의 한 가지로, 특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 법이다.
조금 쉽게 말하자면 답을 재활용한다고 생각하면 된다. 앞에서 구했던걸 뒤에서도 옆에서도 활용하는거다. 사실 dynamic programing 일명 dp는 구체적인 알고리즘이다 보기보다는 물제해결 패러다임에 가깝다. 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고 과거의 구한 해를 활용하는 알고리즘이다. 분할정복 알고리즘과 비슷하며 이름인 dynamic programing 보다는 기억하며 풀기로 생각하는것이 더 좋을수도 있다고 한다.

## 구현
가장 많이 사용하는 피보나치를 예로 들어보자. 피보나치 수열의 5번재를 구하려면 fib(5) = fib(4) + fib(3) ... 으로 파고들어가면 사실 15번정도의 재귀함수 호출이 필요하다. 여기서 5가 아니라 숫자가 커진다면 비례 수준이 아닌 몇제곱의 크기로 수가 커질것이고 시간이 펑 하고 터질거같다. 그래서 깅거하며 풀기가 필요하다. 내가 구한 fib(4), fib(3)을 기록해두어 5를 구할때 또 구하는 일을 피하면 된다. fib(n) = fib(n-1) + fib(n-2) 하기전에 fib(n)이 있는지 확인하고, 값을 구했을때도 리스트에 기록하면 된다. 이런 피보나치 수열 문제는 대표적인 탑다운 방식의 문제인다. 그러면 바텀업 형식의 문제는 뭐가 있을까?

음 점점 하면서 드는 생각이 읽는대로 푸는 문제들은 줄어드는거 같다. 읽는대로 푸는건 뭐 답은 맞아도 시간이 에바다. 해야하는 행동을 세부화 해서 시간복잡도를 따지고 다른 방식으로 간단화 하는 법이 있는지 하나하나 잘 정리해보자.

딱 알아버렸다. 이거 그냥 n번째 일때를 생각하면 된다. 수학적 귀납법 혹은 일반화 처럼 그냥 n번째일때를 어떻게 만드는지를 집중하면 된다. 그때 구할 수 있는 식이 있다면 그 식을 이용해서 1 ~ n가지 bottom-up으로 조지면 n의 복잡도로 클리어 가능이다.